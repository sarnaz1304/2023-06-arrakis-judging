branch_indigo

medium

# Users likely earn fees less than expected in the vault because of incorrect accounting of fees

## Summary
Users likely earn fees less than expected in the vault because of incorrect accounting of fees.
## Vulnerability Detail
In ArrakisV2.sol `burn()`, when a user burns vault shares, liquidity of all active ranges of the vault will be accounted for. Users are entitled to a portion of the total vault liquidity based on the ratio of `burnAmount_` to `totalSupply()`. 
```solidity
//ArrakisV2.sol-burn()

        for (uint256 i; i < _ranges.length; i++) {
            Range memory range = _ranges[i];
            IUniswapV3Pool pool = IUniswapV3Pool(
                factory.getPool(address(token0), address(token1), range.feeTier)
            );
            uint128 liquidity = Position.getLiquidityByRange(
                pool,
                address(this),
                range.lowerTick,
                range.upperTick
            );
            if (liquidity == 0) continue;
>>>          liquidity = SafeCast.toUint128(
                FullMath.mulDiv(liquidity, burnAmount_, ts)
            );
            Withdraw memory withdraw = _withdraw(
                pool,
                range.lowerTick,
                range.upperTick,
                liquidity
            );

```
In `_withdraw()`, user-entitled liquidity calculated from above is converted into the form of token0 and token1 amounts and returned as `burn0` and `burn1`. The liquidity fees generated by this liquidity are returned as `fee0` and `fee1`.  All tokens including earned fees are transferred back to the vault at this point, which is reflected in `balanceOf(address(this))`.

In `burn()`, the leftover token balances in the vault are calculated as `leftOver0` and `leftOver1` based on `balanceOf(address(this))`. However, there is an error in the accounting here. 
```solidity
//ArrakisV2.sol-burn()
...
        _applyFees(total.fee0, total.fee1);
>>>        uint256 leftOver0 = token0.balanceOf(address(this)) -
            managerBalance0 -
            total.burn0;
>>>        uint256 leftOver1 = token1.balanceOf(address(this)) -
            managerBalance1 -
            total.burn1;
         amount0 = FullMath.mulDiv(leftOver0, burnAmount_, ts);
         amount1 = FullMath.mulDiv(leftOver1, burnAmount_, ts);
          amount0 += total.burn0;
          amount1 += total.burn1;
        if (amount0 > 0) {
            token0.safeTransfer(receiver_, amount0);
        }
        if (amount1 > 0) {
            token1.safeTransfer(receiver_, amount1);
        }

```
Because at this point `balanceOf(address(this))` is already increased by `burn0` and `burn1` as well as `fee0` and `fee1`, both burned amount and earned fee amount need to be accounted for. But the calculation only accounted for the burned amount, leaving the user-earned fees as part of the leftover to be shared by other users. This means a user's profits (post manager fee deduction) are always further reduced.

## Impact
Users will lose profit when they burn vault shares. This is especially damaging when the user burned share amount is relatively small compared to total vault shares, because the user will only get back a small fraction of their earned liquidity fees. And the small fraction is disproportional to the liquidity they burned. 

## Code Snippet
[https://github.com/ArrakisFinance/v2-core/blob/9133fc412b65c7a902f62f1ad135f062e927b092/contracts/ArrakisV2.sol#L210-L219](https://github.com/ArrakisFinance/v2-core/blob/9133fc412b65c7a902f62f1ad135f062e927b092/contracts/ArrakisV2.sol#L210-L219)

## Tool used

Manual Review

## Recommendation
Update `total.fee0` and `total.fee1` to reflect user earned fee post manager fee deduction; And change `leftOver0` `leftOver1` calculations into: `uint256 leftOver0 = token0.balanceOf(address(this)) -
            managerBalance0 -
            total.burn0-total.fee0;`
And change the user-earned fee on top of the burned amount and leftover share: ` amount0 += total.burn0 + total.fee0`