n33k

high

# Operator can hijack rebalance control flow inside `swap.router.call` to manipulate pool prices and sandwich attack subsequent liquidity minting

## Summary

Malicious operator can supply crafted swap payload to rebalance which allows him to hijack control flow inside `swap.router.call`.
As a result, the operator can manipulate pool prices, effectively bypassing the deviation check that is performed earlier within SimpleManager. Exploiting this vulnerability, the operator can sandwich attack subsequent liquidity minting to steal the protocol.

## Vulnerability Detail

The malicious operator can do the following steps to launch the attack.

### Hijack control flow in uniswap router call.

The malicious operator first need to deploy a malicious ERC20 token and make a uniswap liquidity pool. Uniswap v3 router is `Multicall`, which means swap payload can both have legitimate swaps and malicious swaps that swap this malicious ERC20 token.

Passing a crafted swap payload to rebalance will make the rebalance call into the malicious token contract during swap. 

### Frontrun liquidity minting in the malicious contract

The operate now has the ability to manipulate pool prices inside his malicious contract.

The deviation check inside `SimpleManager` is bypassed at this stage. He need to bypass following liquidity minting slippage checks inside `ArrakisV2`.

Inside `ArrakisV2::rebalance`, the slippage checks are applied to the aggregated results. A sandwich attacker can bypass these checks by pushing up the price of one pool and reducing the price of another. This will counteract the two slippage effects and correct the final aggregated results.

```solidity
    (uint256 amt0, uint256 amt1) = IUniswapV3Pool(pool).mint(
        address(this),
        rebalanceParams_.mints[i].range.lowerTick,
        rebalanceParams_.mints[i].range.upperTick,
        rebalanceParams_.mints[i].liquidity,
        ""
    );
    aggregator0 += amt0;
    aggregator1 += amt1;
}
require(aggregator0 >= rebalanceParams_.minDeposit0, "D0");
require(aggregator1 >= rebalanceParams_.minDeposit1, "D1");
```

### Backrun with another transaction to finalize the sandwich attack

The attack can backrun the rebalance function with another transaction to finalize the sandwich attack to profit.

## Impact

The malicious operator can sandwich liquidity minting to steal the protocol.

Severity set to High because sandwich liquidity adding will definitely make a profit([a case study](https://eigenphi.substack.com/p/a-brand-new-sandwich-bot-that-could)) and the bypass of slippage protection will enlarge the profit.

## Code Snippet

https://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-core/contracts/ArrakisV2.sol#L334-L337

https://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-core/contracts/ArrakisV2.sol#L398-L409

## Tool used

Manual Review

## Recommendation

The ideal solution is to sandbox `swap.router.call` but it's hard to implement.

Reinforcing slippage checks on liquidity minting may be easier to implement. That is enforcing deviation check inside `ArrakisV2` or checking slippage of each liqudity minting instead of checking the aggregated results.